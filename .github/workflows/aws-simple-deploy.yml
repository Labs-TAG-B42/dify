name: Dify Deploy

on:
  push:
    branches:
      - main
      - master
    paths:
      - '.github/workflows/dify-deploy.yml'
      - 'scripts/**'
  workflow_dispatch:
    inputs:
      dify_version:
        description: 'Versão do Dify (tag ou branch)'
        required: false
        default: 'main'
  schedule:
    # Executar toda segunda-feira às 2h UTC (opcional - para atualizações automáticas)
    - cron: '0 2 * * 1'

env:
  HEALTH_CHECK_TIMEOUT: 300
  HEALTH_CHECK_INTERVAL: 10

jobs:
  deploy:
    name: Deploy Dify to EC2
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/ec2_key
          chmod 600 ~/.ssh/ec2_key
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Test SSH Connection
        run: |
          ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "echo 'SSH connection successful'"

      - name: Backup Current Configuration
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            set -e
            BACKUP_DIR="/home/ubuntu/dify-backup-\$(date +%Y%m%d-%H%M%S)"
            mkdir -p "\$BACKUP_DIR"
            
            if [ -d "/opt/dify" ]; then
              sudo cp -r /opt/dify/.env "\$BACKUP_DIR/.env" 2>/dev/null || true
              sudo cp -r /opt/dify/docker/docker-compose.yaml "\$BACKUP_DIR/docker-compose.yaml" 2>/dev/null || true
              sudo chown -R ubuntu:ubuntu "\$BACKUP_DIR"
              echo "Backup criado em: \$BACKUP_DIR"
            else
              echo "Diretório /opt/dify não existe ainda - primeiro deploy"
            fi
          EOF

      - name: Clone/Update Dify Repository
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            set -e
            DIFY_DIR="/opt/dify"
            DIFY_VERSION="${{ github.event.inputs.dify_version || 'main' }}"
            
            if [ ! -d "\$DIFY_DIR" ]; then
              echo "Clonando repositório Dify..."
              sudo mkdir -p "\$DIFY_DIR"
              sudo git clone https://github.com/langgenius/dify.git "\$DIFY_DIR"
              sudo chown -R ubuntu:ubuntu "\$DIFY_DIR"
            elif [ ! -d "\$DIFY_DIR/.git" ]; then
              echo "Diretório existe mas não é um repositório git. Recriando..."
              sudo rm -rf "\$DIFY_DIR"
              sudo mkdir -p "\$DIFY_DIR"
              sudo git clone https://github.com/langgenius/dify.git "\$DIFY_DIR"
              sudo chown -R ubuntu:ubuntu "\$DIFY_DIR"
            else
              echo "Atualizando repositório Dify..."
              cd "\$DIFY_DIR"
              sudo -u ubuntu git fetch origin
              sudo -u ubuntu git checkout "\$DIFY_VERSION" || sudo -u ubuntu git checkout main
              sudo -u ubuntu git pull origin "\$DIFY_VERSION" || sudo -u ubuntu git pull origin main
            fi
            
            cd "\$DIFY_DIR"
            echo "Versão atual: \$(sudo -u ubuntu git rev-parse --short HEAD)"
            
            # Garantir permissões corretas nos diretórios de storage
            # O container roda como usuário dify (uid=1001, gid=1001)
            echo "Configurando permissões dos diretórios de storage..."
            sudo mkdir -p "\$DIFY_DIR/docker/volumes/app/storage"
            sudo chown -R 1001:1001 "\$DIFY_DIR/docker/volumes/app/storage"
            sudo chmod -R 755 "\$DIFY_DIR/docker/volumes/app/storage"
          EOF

      - name: Update Environment File
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            set -e
            DIFY_DIR="/opt/dify"
            
            if [ ! -f "\$DIFY_DIR/.env" ]; then
              echo "Criando arquivo .env..."
              sudo cp "\$DIFY_DIR/.env.example" "\$DIFY_DIR/.env" 2>/dev/null || sudo touch "\$DIFY_DIR/.env"
              sudo chown ubuntu:ubuntu "\$DIFY_DIR/.env"
            fi
            
            # Atualizar variáveis de ambiente do banco de dados RDS
            # Usar DATABASE_URL completa ou variáveis individuais
            DATABASE_URL="${{ secrets.DATABASE_URL }}"
            DB_HOST="${{ secrets.DB_HOST }}"
            DB_PORT="${{ secrets.DB_PORT }}"
            DB_USERNAME="${{ secrets.DB_USERNAME }}"
            DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            DB_DATABASE="${{ secrets.DB_DATABASE }}"
            SECRET_KEY="${{ secrets.DIFY_SECRET_KEY }}"
            
            # Limpar variáveis antigas do banco de dados antes de adicionar novas
            echo "Limpando variáveis antigas do banco de dados..."
            sudo sed -i '/^DB_HOST=/d' "\$DIFY_DIR/.env" 2>/dev/null || true
            sudo sed -i '/^DB_PORT=/d' "\$DIFY_DIR/.env" 2>/dev/null || true
            sudo sed -i '/^DB_USERNAME=/d' "\$DIFY_DIR/.env" 2>/dev/null || true
            sudo sed -i '/^DB_PASSWORD=/d' "\$DIFY_DIR/.env" 2>/dev/null || true
            sudo sed -i '/^DB_DATABASE=/d' "\$DIFY_DIR/.env" 2>/dev/null || true
            sudo sed -i '/^DATABASE_URL=/d' "\$DIFY_DIR/.env" 2>/dev/null || true
            sudo sed -i '/^PGHOSTADDR=/d' "\$DIFY_DIR/.env" 2>/dev/null || true
            
            # Configurar banco de dados (prioridade: DATABASE_URL > variáveis individuais)
            if [ -n "\$DATABASE_URL" ] && [ "\$DATABASE_URL" != "" ]; then
              echo "Configurando banco de dados usando DATABASE_URL..."
              
              # Adicionar DATABASE_URL
              echo "DATABASE_URL=\$DATABASE_URL" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
              
              # Extrair componentes da URL para variáveis individuais
              # Usar regex manual porque urlparse não lida bem com caracteres especiais na senha (#, (, ), etc.)
              echo 'import re' > /tmp/parse_db_url.py
              echo 'import sys' >> /tmp/parse_db_url.py
              echo 'import urllib.parse' >> /tmp/parse_db_url.py
              echo 'url = sys.stdin.read().strip()' >> /tmp/parse_db_url.py
              echo 'if url:' >> /tmp/parse_db_url.py
              echo '    try:' >> /tmp/parse_db_url.py
              echo '        # Remover o scheme (postgresql://) primeiro' >> /tmp/parse_db_url.py
              echo '        if "://" in url:' >> /tmp/parse_db_url.py
              echo '            url = url.split("://", 1)[1]' >> /tmp/parse_db_url.py
              echo '        # Regex para capturar: username:password@host:port/database' >> /tmp/parse_db_url.py
              echo '        # A senha pode conter qualquer caractere, então capturamos tudo até @' >> /tmp/parse_db_url.py
              echo '        pattern = r'"'"'^([^:]+):([^@]+)@([^:]+):(\d+)/([^?#]+)'"'"'' >> /tmp/parse_db_url.py
              echo '        match = re.match(pattern, url)' >> /tmp/parse_db_url.py
              echo '        if match:' >> /tmp/parse_db_url.py
              echo '            username = urllib.parse.unquote(match.group(1))' >> /tmp/parse_db_url.py
              echo '            password = urllib.parse.unquote(match.group(2))' >> /tmp/parse_db_url.py
              echo '            host = match.group(3)' >> /tmp/parse_db_url.py
              echo '            port = match.group(4)' >> /tmp/parse_db_url.py
              echo '            database = match.group(5)' >> /tmp/parse_db_url.py
              echo '            print(f'"'"'DB_USERNAME={username}'"'"')' >> /tmp/parse_db_url.py
              echo '            print(f'"'"'DB_PASSWORD={password}'"'"')' >> /tmp/parse_db_url.py
              echo '            print(f'"'"'DB_HOST={host}'"'"')' >> /tmp/parse_db_url.py
              echo '            print(f'"'"'DB_PORT={port}'"'"')' >> /tmp/parse_db_url.py
              echo '            print(f'"'"'DB_DATABASE={database}'"'"')' >> /tmp/parse_db_url.py
              echo '        else:' >> /tmp/parse_db_url.py
              echo '            print('"'"'ERROR: URL format not recognized'"'"', file=sys.stderr)' >> /tmp/parse_db_url.py
              echo '            print(f'"'"'DEBUG: URL after removing scheme: {url[:100]}...'"'"', file=sys.stderr)' >> /tmp/parse_db_url.py
              echo '    except Exception as e:' >> /tmp/parse_db_url.py
              echo '        print(f'"'"'ERROR: {e}'"'"', file=sys.stderr)' >> /tmp/parse_db_url.py
              echo '        import traceback' >> /tmp/parse_db_url.py
              echo '        traceback.print_exc(file=sys.stderr)' >> /tmp/parse_db_url.py
              
              echo "DEBUG: Tentando parsear DATABASE_URL..."
              printf '%s' "\$DATABASE_URL" | python3 /tmp/parse_db_url.py > /tmp/db_vars.txt 2>/tmp/db_vars_error.txt
              ERROR_OUTPUT=\$(cat /tmp/db_vars_error.txt 2>/dev/null || echo "")
              rm -f /tmp/parse_db_url.py /tmp/db_vars_error.txt
              
              if [ -n "\$ERROR_OUTPUT" ]; then
                echo "DEBUG: Erros do parser:"
                echo "\$ERROR_OUTPUT"
              fi
              
              if [ -f /tmp/db_vars.txt ] && [ -s /tmp/db_vars.txt ] && ! grep -q "ERROR" /tmp/db_vars.txt; then
                echo "Variáveis extraídas do DATABASE_URL:"
                cat /tmp/db_vars.txt | sed 's/\(DB_PASSWORD=\).*/\1***MASKED***/'
                echo ""
                
                # Adicionar variáveis ao arquivo .env
                while IFS='=' read -r KEY VALUE; do
                  [ -z "\$KEY" ] && continue
                  [ "\${KEY#\#}" != "\$KEY" ] && continue
                  
                  if [ -n "\$KEY" ] && [ -n "\$VALUE" ]; then
                    KEY=\$(echo "\$KEY" | xargs)
                    VALUE=\$(echo "\$VALUE" | xargs)
                    echo "\${KEY}=\${VALUE}" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
                    echo "Adicionado: \${KEY}"
                  fi
                done < /tmp/db_vars.txt
                rm -f /tmp/db_vars.txt
              else
                echo "AVISO: Não foi possível extrair variáveis individuais da DATABASE_URL"
                echo "Conteúdo do arquivo temporário:"
                cat /tmp/db_vars.txt 2>&1 || echo "Arquivo vazio ou não existe"
                echo ""
                echo "Usando apenas DATABASE_URL (o Dify pode funcionar apenas com DATABASE_URL)"
                echo "A DATABASE_URL já foi adicionada ao arquivo .env"
                # As variáveis individuais são opcionais se DATABASE_URL estiver configurada
                # O Dify pode usar DATABASE_URL diretamente
                rm -f /tmp/db_vars.txt
              fi
            elif [ -n "\$DB_HOST" ] && [ "\$DB_HOST" != "" ]; then
              echo "Configurando banco de dados usando variáveis individuais..."
              
              # Adicionar variáveis individuais
              [ -n "\$DB_HOST" ] && echo "DB_HOST=\$DB_HOST" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
              [ -n "\$DB_PORT" ] && echo "DB_PORT=\${DB_PORT:-5432}" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
              [ -n "\$DB_USERNAME" ] && echo "DB_USERNAME=\$DB_USERNAME" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
              [ -n "\$DB_PASSWORD" ] && echo "DB_PASSWORD=\$DB_PASSWORD" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
              [ -n "\$DB_DATABASE" ] && echo "DB_DATABASE=\$DB_DATABASE" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
              
              # Construir DATABASE_URL
              DB_PORT_VALUE=\${DB_PORT:-5432}
              DATABASE_URL_VALUE="postgresql://\${DB_USERNAME}:\${DB_PASSWORD}@\${DB_HOST}:\${DB_PORT_VALUE}/\${DB_DATABASE}"
              echo "DATABASE_URL=\$DATABASE_URL_VALUE" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
              echo "DATABASE_URL criada a partir das variáveis individuais"
              
              echo "Variáveis de banco de dados configuradas"
            else
              echo "AVISO: Nenhuma configuração de banco de dados fornecida (DATABASE_URL ou variáveis DB_*)"
            fi
            
            # Limpar e configurar SECRET_KEY
            if [ -n "\$SECRET_KEY" ] && [ "\$SECRET_KEY" != "" ]; then
              sudo sed -i '/^SECRET_KEY=/d' "\$DIFY_DIR/.env" 2>/dev/null || true
              echo "SECRET_KEY=\$SECRET_KEY" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
            fi
            
            # Limpar e configurar Redis (usar nome do serviço Docker Compose)
            sudo sed -i '/^REDIS_HOST=/d' "\$DIFY_DIR/.env" 2>/dev/null || true
            sudo sed -i '/^REDIS_PORT=/d' "\$DIFY_DIR/.env" 2>/dev/null || true
            echo "REDIS_HOST=redis" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
            echo "REDIS_PORT=6379" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
            
            # Configurar banco para plugin_daemon
            # Criar banco dify_plugin se não existir (usando psql na EC2)
            if [ -n "\$DATABASE_URL" ] && [ "\$DATABASE_URL" != "" ]; then
              echo "Verificando/criando banco dify_plugin..."
              # Extrair componentes da URL usando sed
              DB_HOST=\$(echo "\$DATABASE_URL" | sed -n 's|.*@\([^:]*\):.*|\1|p')
              DB_PORT=\$(echo "\$DATABASE_URL" | sed -n 's|.*:\([0-9]*\)/.*|\1|p')
              DB_USER=\$(echo "\$DATABASE_URL" | sed -n 's|.*://\([^:]*\):.*|\1|p')
              DB_PASS=\$(echo "\$DATABASE_URL" | sed -n 's|.*://[^:]*:\([^@]*\)@.*|\1|p')
              
              # Verificar se banco existe, se não, criar usando psql
              if command -v psql > /dev/null 2>&1; then
                PGPASSWORD="\$DB_PASS" psql -h "\$DB_HOST" -p "\${DB_PORT:-5432}" -U "\$DB_USER" -d postgres -tc "SELECT 1 FROM pg_database WHERE datname='dify_plugin'" | grep -q 1 || \
                  PGPASSWORD="\$DB_PASS" psql -h "\$DB_HOST" -p "\${DB_PORT:-5432}" -U "\$DB_USER" -d postgres -c "CREATE DATABASE dify_plugin" 2>/dev/null && \
                  echo "Banco dify_plugin criado" || echo "Banco dify_plugin já existe ou erro ao criar"
              else
                echo "AVISO: psql não está disponível, banco dify_plugin deve ser criado manualmente"
              fi
            fi
            
            # Configurar variáveis do plugin_daemon
            sudo sed -i '/^DB_PLUGIN_DATABASE=/d' "\$DIFY_DIR/.env" 2>/dev/null || true
            echo "DB_PLUGIN_DATABASE=dify_plugin" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
            
            sudo chown ubuntu:ubuntu "\$DIFY_DIR/.env"
            
            # Copiar .env para docker/.env também (Docker Compose pode procurar lá)
            if [ -f "\$DIFY_DIR/.env" ]; then
              sudo cp "\$DIFY_DIR/.env" "\$DIFY_DIR/docker/.env" 2>/dev/null || true
              sudo chown ubuntu:ubuntu "\$DIFY_DIR/docker/.env" 2>/dev/null || true
            fi
            
            echo "Arquivo .env atualizado"
          EOF

      - name: Update Docker Compose
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            set -e
            DIFY_DIR="/opt/dify"
            cd "\$DIFY_DIR"
            
            # Comentar serviço PostgreSQL se existir (usando Supabase externo)
            if [ -f "docker/docker-compose.yaml" ]; then
              sudo sed -i 's/^[[:space:]]*postgresql:/# postgresql:/' docker/docker-compose.yaml || true
              sudo sed -i '/^[[:space:]]*postgresql:/,/^[[:space:]]*[a-z]/ { /^[[:space:]]*[a-z]/! s/^/# / }' docker/docker-compose.yaml || true
              sudo chown ubuntu:ubuntu docker/docker-compose.yaml
            fi
            
            # Garantir que plugin_daemon está habilitado (não comentado)
            # O plugin_daemon agora está configurado com RDS que permite conexões sem SSL
            if [ -f "docker/docker-compose.yaml" ]; then
              # Descomentar plugin_daemon se estiver comentado
              sudo sed -i 's/^[[:space:]]*# plugin_daemon:/  plugin_daemon:/' docker/docker-compose.yaml || true
              sudo sed -i '/^[[:space:]]*# plugin_daemon:/,/^[[:space:]]*[a-z_]*:/ { s/^[[:space:]]*# /  / }' docker/docker-compose.yaml || true
              sudo chown ubuntu:ubuntu docker/docker-compose.yaml
              echo "Plugin daemon verificado no docker-compose.yaml"
            fi
            
            # Garantir permissões corretas nos diretórios de storage
            echo "Configurando permissões dos diretórios de storage..."
            sudo mkdir -p "docker/volumes/app/storage"
            sudo chown -R 1001:1001 "docker/volumes/app/storage"
            sudo chmod -R 755 "docker/volumes/app/storage"
            
            echo "Docker Compose atualizado"
          EOF

      - name: Pull Docker Images
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            set -e
            DIFY_DIR="/opt/dify"
            cd "\$DIFY_DIR"
            
            # Usar docker-compose ou docker compose dependendo da versão
            if command -v docker-compose &> /dev/null; then
              COMPOSE_CMD="docker-compose"
            else
              COMPOSE_CMD="docker compose"
            fi
            
            # Garantir que o .env está no local correto (docker-compose procura no mesmo diretório do compose file)
            if [ -f "\$DIFY_DIR/.env" ]; then
              sudo cp "\$DIFY_DIR/.env" "\$DIFY_DIR/docker/.env" 2>/dev/null || true
              sudo chown ubuntu:ubuntu "\$DIFY_DIR/docker/.env" 2>/dev/null || true
            fi
            
            # Garantir permissões corretas nos diretórios de storage antes de iniciar containers
            echo "Verificando permissões dos diretórios de storage..."
            sudo mkdir -p "\$DIFY_DIR/docker/volumes/app/storage"
            sudo chown -R 1001:1001 "\$DIFY_DIR/docker/volumes/app/storage"
            sudo chmod -R 755 "\$DIFY_DIR/docker/volumes/app/storage"
            
            echo "Fazendo pull das imagens Docker..."
            # Executar do diretório docker/ para que o .env seja encontrado automaticamente
            cd "\$DIFY_DIR/docker"
            sudo \$COMPOSE_CMD -f docker-compose.yaml pull || true
          EOF

      - name: Restart Dify Containers
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            set -e
            DIFY_DIR="/opt/dify"
            cd "\$DIFY_DIR"
            
            # Usar docker-compose ou docker compose dependendo da versão
            if command -v docker-compose &> /dev/null; then
              COMPOSE_CMD="docker-compose"
            else
              COMPOSE_CMD="docker compose"
            fi
            
            # Garantir que o .env está no local correto (docker-compose procura no mesmo diretório do compose file)
            if [ -f "\$DIFY_DIR/.env" ]; then
              sudo cp "\$DIFY_DIR/.env" "\$DIFY_DIR/docker/.env" 2>/dev/null || true
              sudo chown ubuntu:ubuntu "\$DIFY_DIR/docker/.env" 2>/dev/null || true
            fi
            
            echo "Reiniciando containers Dify..."
            
            # Verificar se o .env existe e mostrar conteúdo
            echo "=== Verificando arquivo .env em \$DIFY_DIR/.env ==="
            if [ -f "\$DIFY_DIR/.env" ]; then
              echo "Arquivo .env encontrado. Tamanho: \$(wc -l < "\$DIFY_DIR/.env") linhas"
              echo "Conteúdo completo (mascarando senha):"
              sed 's/\(DB_PASSWORD=\).*/\1***MASKED***/' "\$DIFY_DIR/.env" | head -50
              echo ""
              echo "Verificando variáveis DB_* específicas:"
              grep "^DB_" "\$DIFY_DIR/.env" | sed 's/\(DB_PASSWORD=\).*/\1***MASKED***/' || echo "Nenhuma variável DB_* encontrada no arquivo!"
            else
              echo "ERRO: Arquivo .env não encontrado em \$DIFY_DIR/.env"
            fi
            
            # Garantir que o .env está em docker/ também
            if [ -f "\$DIFY_DIR/.env" ]; then
              echo "Copiando .env para docker/.env..."
              sudo cp "\$DIFY_DIR/.env" "\$DIFY_DIR/docker/.env"
              sudo chown ubuntu:ubuntu "\$DIFY_DIR/docker/.env"
              echo "Arquivo copiado. Verificando docker/.env:"
              if [ -f "\$DIFY_DIR/docker/.env" ]; then
                echo "docker/.env existe. Tamanho: \$(wc -l < "\$DIFY_DIR/docker/.env") linhas"
                grep "^DB_" "\$DIFY_DIR/docker/.env" | sed 's/\(DB_PASSWORD=\).*/\1***MASKED***/' || echo "Nenhuma variável DB_* em docker/.env!"
              fi
            fi
            
            # Executar do diretório docker/ e carregar o .env explicitamente
            cd "\$DIFY_DIR/docker"
            
            # Verificar o arquivo .env antes de carregar
            echo "=== Verificando .env no diretório docker/ ==="
            if [ -f .env ]; then
              echo "Arquivo .env encontrado em docker/.env"
              echo "Primeiras 20 linhas:"
              head -20 .env | sed 's/\(DB_PASSWORD=\).*/\1***MASKED***/'
              echo ""
              echo "Variáveis DB_* no arquivo:"
              grep "^DB_" .env | sed 's/\(DB_PASSWORD=\).*/\1***MASKED***/' || echo "ERRO: Nenhuma variável DB_* encontrada!"
              
              # Validar que não há valores duplicados/concatenados
              if grep -q "DB_HOST=.*DB_HOST=" .env 2>/dev/null; then
                echo "ERRO: Arquivo .env contém valores duplicados/concatenados!"
                echo "Limpando e recriando a partir do arquivo principal..."
                sudo cp "\$DIFY_DIR/.env" .env 2>/dev/null || true
                sudo chown ubuntu:ubuntu .env
              fi
              
              # Remover duplicatas de variáveis (manter apenas a primeira ocorrência)
              for VAR in DB_HOST DB_PORT DB_USERNAME DB_PASSWORD DB_DATABASE DATABASE_URL; do
                COUNT=\$(grep -c "^${VAR}=" .env 2>/dev/null || echo "0")
                if [ "\$COUNT" -gt 1 ]; then
                  echo "AVISO: Variável \${VAR} aparece \${COUNT} vezes. Removendo duplicatas..."
                  FIRST_LINE=\$(grep -n "^${VAR}=" .env | head -1 | cut -d: -f1)
                  sudo sed -i "\${FIRST_LINE}!{/^${VAR}=/d}" .env
                fi
              done
              
              # Carregar variáveis do .env usando source (com tratamento de erro)
              echo "Carregando variáveis do arquivo .env..."
              set +e
              set -a
              source .env 2>&1 | grep -v "syntax error" || true
              set +a
              set -e
              
              echo "Variáveis de ambiente exportadas (verificando DB_*):"
              env | grep "^DB_" | sed 's/\(DB_PASSWORD=\).*/\1***MASKED***/' || echo "ERRO: Nenhuma variável DB_* encontrada no ambiente!"
            else
              echo "ERRO: Arquivo .env não encontrado em docker/.env"
              echo "Listando arquivos em docker/:"
              ls -la | head -10
            fi
            
            # Executar docker compose com as variáveis exportadas
            # -E preserva as variáveis de ambiente ao usar sudo
            sudo -E \$COMPOSE_CMD -f docker-compose.yaml down || true
            sudo -E \$COMPOSE_CMD -f docker-compose.yaml up -d
            
            echo "Containers reiniciados"
            sudo \$COMPOSE_CMD -f docker-compose.yaml ps
          EOF

      - name: Health Check
        run: |
          HEALTH_URL="${{ secrets.HEALTH_CHECK_URL || format('http://{0}', secrets.EC2_HOST) }}"
          TIMEOUT=${{ env.HEALTH_CHECK_TIMEOUT }}
          INTERVAL=${{ env.HEALTH_CHECK_INTERVAL }}
          ELAPSED=0
          
          echo "Aguardando Dify ficar disponível em $HEALTH_URL..."
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if curl -f -s "$HEALTH_URL" > /dev/null 2>&1 || curl -f -s "$HEALTH_URL/health" > /dev/null 2>&1; then
              echo "✅ Dify está respondendo!"
              exit 0
            fi
            
            echo "Aguardando... ($ELAPSED/$TIMEOUT segundos)"
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          echo "❌ Timeout: Dify não respondeu após $TIMEOUT segundos"
          exit 1

      - name: Rollback on Failure
        if: failure()
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            set -e
            DIFY_DIR="/opt/dify"
            BACKUP_DIR=\$(ls -td /home/ubuntu/dify-backup-* 2>/dev/null | head -1)
            
            if [ -n "\$BACKUP_DIR" ] && [ -d "\$BACKUP_DIR" ]; then
              echo "Fazendo rollback usando backup: \$BACKUP_DIR"
              cd "\$DIFY_DIR"
              
              if command -v docker-compose &> /dev/null; then
                COMPOSE_CMD="docker-compose"
              else
                COMPOSE_CMD="docker compose"
              fi
              
              # Garantir que o .env está no local correto
              if [ -f "\$BACKUP_DIR/.env" ]; then
                sudo cp "\$BACKUP_DIR/.env" "\$DIFY_DIR/.env"
                sudo cp "\$BACKUP_DIR/.env" "\$DIFY_DIR/docker/.env"
                sudo chown ubuntu:ubuntu "\$DIFY_DIR/.env"
                sudo chown ubuntu:ubuntu "\$DIFY_DIR/docker/.env"
              fi
              
              if [ -f "\$BACKUP_DIR/docker-compose.yaml" ]; then
                sudo cp "\$BACKUP_DIR/docker-compose.yaml" "\$DIFY_DIR/docker/docker-compose.yaml"
                sudo chown ubuntu:ubuntu "\$DIFY_DIR/docker/docker-compose.yaml"
              fi
              
              # Executar do diretório docker/ para que o .env seja encontrado automaticamente
              cd "\$DIFY_DIR/docker"
              sudo \$COMPOSE_CMD -f docker-compose.yaml down
              sudo \$COMPOSE_CMD -f docker-compose.yaml up -d
              echo "Rollback concluído"
            else
              echo "Nenhum backup encontrado para rollback"
            fi
          EOF

