name: Dify Deploy

on:
  push:
    branches:
      - main
      - master
    paths:
      - '.github/workflows/dify-deploy.yml'
      - 'scripts/**'
  workflow_dispatch:
    inputs:
      dify_version:
        description: 'Versão do Dify (tag ou branch)'
        required: false
        default: 'main'
  schedule:
    # Executar toda segunda-feira às 2h UTC (opcional - para atualizações automáticas)
    - cron: '0 2 * * 1'

env:
  HEALTH_CHECK_TIMEOUT: 300
  HEALTH_CHECK_INTERVAL: 10

jobs:
  deploy:
    name: Deploy Dify to EC2
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/ec2_key
          chmod 600 ~/.ssh/ec2_key
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Test SSH Connection
        run: |
          ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "echo 'SSH connection successful'"

      - name: Backup Current Configuration
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            set -e
            BACKUP_DIR="/home/ubuntu/dify-backup-\$(date +%Y%m%d-%H%M%S)"
            mkdir -p "\$BACKUP_DIR"
            
            if [ -d "/opt/dify" ]; then
              sudo cp -r /opt/dify/.env "\$BACKUP_DIR/.env" 2>/dev/null || true
              sudo cp -r /opt/dify/docker/docker-compose.yaml "\$BACKUP_DIR/docker-compose.yaml" 2>/dev/null || true
              sudo chown -R ubuntu:ubuntu "\$BACKUP_DIR"
              echo "Backup criado em: \$BACKUP_DIR"
            else
              echo "Diretório /opt/dify não existe ainda - primeiro deploy"
            fi
          EOF

      - name: Clone/Update Dify Repository
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            set -e
            DIFY_DIR="/opt/dify"
            DIFY_VERSION="${{ github.event.inputs.dify_version || 'main' }}"
            
            if [ ! -d "\$DIFY_DIR" ]; then
              echo "Clonando repositório Dify..."
              sudo mkdir -p "\$DIFY_DIR"
              sudo git clone https://github.com/langgenius/dify.git "\$DIFY_DIR"
              sudo chown -R ubuntu:ubuntu "\$DIFY_DIR"
            elif [ ! -d "\$DIFY_DIR/.git" ]; then
              echo "Diretório existe mas não é um repositório git. Recriando..."
              sudo rm -rf "\$DIFY_DIR"
              sudo mkdir -p "\$DIFY_DIR"
              sudo git clone https://github.com/langgenius/dify.git "\$DIFY_DIR"
              sudo chown -R ubuntu:ubuntu "\$DIFY_DIR"
            else
              echo "Atualizando repositório Dify..."
              cd "\$DIFY_DIR"
              sudo -u ubuntu git fetch origin
              sudo -u ubuntu git checkout "\$DIFY_VERSION" || sudo -u ubuntu git checkout main
              sudo -u ubuntu git pull origin "\$DIFY_VERSION" || sudo -u ubuntu git pull origin main
            fi
            
            cd "\$DIFY_DIR"
            echo "Versão atual: \$(sudo -u ubuntu git rev-parse --short HEAD)"
          EOF

      - name: Update Environment File
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            set -e
            DIFY_DIR="/opt/dify"
            
            if [ ! -f "\$DIFY_DIR/.env" ]; then
              echo "Criando arquivo .env..."
              sudo cp "\$DIFY_DIR/.env.example" "\$DIFY_DIR/.env" 2>/dev/null || sudo touch "\$DIFY_DIR/.env"
              sudo chown ubuntu:ubuntu "\$DIFY_DIR/.env"
            fi
            
            # Atualizar variáveis de ambiente se fornecidas
            SUPABASE_URL="${{ secrets.SUPABASE_DATABASE_URL }}"
            SECRET_KEY="${{ secrets.DIFY_SECRET_KEY }}"
            
            if [ -n "\$SUPABASE_URL" ] && [ "\$SUPABASE_URL" != "" ]; then
              echo "Configurando banco de dados Supabase..."
              
              # Configurar DATABASE_URL (formato completo)
              sudo sed -i 's|^DATABASE_URL=.*|DATABASE_URL='"\$SUPABASE_URL"'|' "\$DIFY_DIR/.env" || echo "DATABASE_URL=\$SUPABASE_URL" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
              
              # Extrair componentes da URL do Supabase usando Python
              # Formato: postgresql://user:password@host:port/database
              # Criar script Python temporário usando echo para evitar problemas de parsing YAML
              echo 'import re' > /tmp/parse_db_url.py
              echo 'import sys' >> /tmp/parse_db_url.py
              echo 'url = sys.stdin.read().strip()' >> /tmp/parse_db_url.py
              echo 'if url:' >> /tmp/parse_db_url.py
              echo '    pattern = r'"'"'postgresql://([^:]+):([^@]+)@([^:]+):(\d+)/([^?]+)'"'"'' >> /tmp/parse_db_url.py
              echo '    match = re.match(pattern, url)' >> /tmp/parse_db_url.py
              echo '    if match:' >> /tmp/parse_db_url.py
              echo '        username = match.group(1)' >> /tmp/parse_db_url.py
              echo '        password = match.group(2)' >> /tmp/parse_db_url.py
              echo '        host = match.group(3)' >> /tmp/parse_db_url.py
              echo '        port = match.group(4)' >> /tmp/parse_db_url.py
              echo '        database = match.group(5)' >> /tmp/parse_db_url.py
              echo '        print(f'"'"'DB_USERNAME={username}'"'"')' >> /tmp/parse_db_url.py
              echo '        print(f'"'"'DB_PASSWORD={password}'"'"')' >> /tmp/parse_db_url.py
              echo '        print(f'"'"'DB_HOST={host}'"'"')' >> /tmp/parse_db_url.py
              echo '        print(f'"'"'DB_PORT={port}'"'"')' >> /tmp/parse_db_url.py
              echo '        print(f'"'"'DB_DATABASE={database}'"'"')' >> /tmp/parse_db_url.py
              echo '    else:' >> /tmp/parse_db_url.py
              echo '        print('"'"'ERROR: URL format not recognized'"'"', file=sys.stderr)' >> /tmp/parse_db_url.py
              
              # Executar script Python com a URL
              printf '%s' "\$SUPABASE_URL" | python3 /tmp/parse_db_url.py > /tmp/db_vars.txt 2>&1
              rm -f /tmp/parse_db_url.py
              
              # Verificar se o arquivo foi criado e tem conteúdo
              if [ -f /tmp/db_vars.txt ] && [ -s /tmp/db_vars.txt ] && ! grep -q "ERROR" /tmp/db_vars.txt; then
                echo "Variáveis extraídas do banco de dados:"
                cat /tmp/db_vars.txt
                
                # Configurar variáveis do arquivo temporário
                while IFS='=' read -r KEY VALUE; do
                  if [ -n "\$KEY" ] && [ -n "\$VALUE" ]; then
                    # Escapar caracteres especiais na senha para sed
                    ESCAPED_VALUE=\$(printf '%s' "\$VALUE" | sed 's/[[\.*^$()+?{|]/\\&/g')
                    sudo sed -i "s|^\${KEY}=.*|\${KEY}=\${ESCAPED_VALUE}|" "\$DIFY_DIR/.env" || echo "\${KEY}=\${VALUE}" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
                    echo "Configurado: \${KEY}"
                  fi
                done < /tmp/db_vars.txt
                rm -f /tmp/db_vars.txt
              else
                echo "ERRO: Não foi possível extrair variáveis da URL do banco de dados"
                cat /tmp/db_vars.txt 2>&1 || true
                rm -f /tmp/db_vars.txt
              fi
              
              sudo chown ubuntu:ubuntu "\$DIFY_DIR/.env"
            else
              echo "AVISO: SUPABASE_DATABASE_URL não foi fornecido"
            fi
            
            if [ -n "\$SECRET_KEY" ] && [ "\$SECRET_KEY" != "" ]; then
              sudo sed -i 's|^SECRET_KEY=.*|SECRET_KEY='"\$SECRET_KEY"'|' "\$DIFY_DIR/.env" || echo "SECRET_KEY=\$SECRET_KEY" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
              sudo chown ubuntu:ubuntu "\$DIFY_DIR/.env"
            fi
            
            # Configurar Redis local
            sudo sed -i 's|^REDIS_HOST=.*|REDIS_HOST=localhost|' "\$DIFY_DIR/.env" || echo "REDIS_HOST=localhost" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
            sudo sed -i 's|^REDIS_PORT=.*|REDIS_PORT=6379|' "\$DIFY_DIR/.env" || echo "REDIS_PORT=6379" | sudo tee -a "\$DIFY_DIR/.env" > /dev/null
            sudo chown ubuntu:ubuntu "\$DIFY_DIR/.env"
            
            # Copiar .env para docker/.env também (Docker Compose pode procurar lá)
            if [ -f "\$DIFY_DIR/.env" ]; then
              sudo cp "\$DIFY_DIR/.env" "\$DIFY_DIR/docker/.env" 2>/dev/null || true
              sudo chown ubuntu:ubuntu "\$DIFY_DIR/docker/.env" 2>/dev/null || true
            fi
            
            echo "Arquivo .env atualizado"
          EOF

      - name: Update Docker Compose
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            set -e
            DIFY_DIR="/opt/dify"
            cd "\$DIFY_DIR"
            
            # Comentar serviço PostgreSQL se existir (usando Supabase externo)
            if [ -f "docker/docker-compose.yaml" ]; then
              sudo sed -i 's/^[[:space:]]*postgresql:/# postgresql:/' docker/docker-compose.yaml || true
              sudo sed -i '/^[[:space:]]*postgresql:/,/^[[:space:]]*[a-z]/ { /^[[:space:]]*[a-z]/! s/^/# / }' docker/docker-compose.yaml || true
              sudo chown ubuntu:ubuntu docker/docker-compose.yaml
            fi
            
            echo "Docker Compose atualizado"
          EOF

      - name: Pull Docker Images
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            set -e
            DIFY_DIR="/opt/dify"
            cd "\$DIFY_DIR"
            
            # Usar docker-compose ou docker compose dependendo da versão
            if command -v docker-compose &> /dev/null; then
              COMPOSE_CMD="docker-compose"
            else
              COMPOSE_CMD="docker compose"
            fi
            
            # Garantir que o .env está no local correto (docker-compose procura no mesmo diretório do compose file)
            if [ -f "\$DIFY_DIR/.env" ]; then
              sudo cp "\$DIFY_DIR/.env" "\$DIFY_DIR/docker/.env" 2>/dev/null || true
              sudo chown ubuntu:ubuntu "\$DIFY_DIR/docker/.env" 2>/dev/null || true
            fi
            
            echo "Fazendo pull das imagens Docker..."
            # Executar do diretório docker/ para que o .env seja encontrado automaticamente
            cd "\$DIFY_DIR/docker"
            sudo \$COMPOSE_CMD -f docker-compose.yaml pull || true
          EOF

      - name: Restart Dify Containers
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            set -e
            DIFY_DIR="/opt/dify"
            cd "\$DIFY_DIR"
            
            # Usar docker-compose ou docker compose dependendo da versão
            if command -v docker-compose &> /dev/null; then
              COMPOSE_CMD="docker-compose"
            else
              COMPOSE_CMD="docker compose"
            fi
            
            # Garantir que o .env está no local correto (docker-compose procura no mesmo diretório do compose file)
            if [ -f "\$DIFY_DIR/.env" ]; then
              sudo cp "\$DIFY_DIR/.env" "\$DIFY_DIR/docker/.env" 2>/dev/null || true
              sudo chown ubuntu:ubuntu "\$DIFY_DIR/docker/.env" 2>/dev/null || true
            fi
            
            echo "Reiniciando containers Dify..."
            # Executar do diretório docker/ para que o .env seja encontrado automaticamente
            cd "\$DIFY_DIR/docker"
            sudo \$COMPOSE_CMD -f docker-compose.yaml down || true
            sudo \$COMPOSE_CMD -f docker-compose.yaml up -d
            
            echo "Containers reiniciados"
            sudo \$COMPOSE_CMD -f docker-compose.yaml ps
          EOF

      - name: Health Check
        run: |
          HEALTH_URL="${{ secrets.HEALTH_CHECK_URL || format('http://{0}', secrets.EC2_HOST) }}"
          TIMEOUT=${{ env.HEALTH_CHECK_TIMEOUT }}
          INTERVAL=${{ env.HEALTH_CHECK_INTERVAL }}
          ELAPSED=0
          
          echo "Aguardando Dify ficar disponível em $HEALTH_URL..."
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if curl -f -s "$HEALTH_URL" > /dev/null 2>&1 || curl -f -s "$HEALTH_URL/health" > /dev/null 2>&1; then
              echo "✅ Dify está respondendo!"
              exit 0
            fi
            
            echo "Aguardando... ($ELAPSED/$TIMEOUT segundos)"
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          echo "❌ Timeout: Dify não respondeu após $TIMEOUT segundos"
          exit 1

      - name: Rollback on Failure
        if: failure()
        run: |
          ssh -i ~/.ssh/ec2_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOF
            set -e
            DIFY_DIR="/opt/dify"
            BACKUP_DIR=\$(ls -td /home/ubuntu/dify-backup-* 2>/dev/null | head -1)
            
            if [ -n "\$BACKUP_DIR" ] && [ -d "\$BACKUP_DIR" ]; then
              echo "Fazendo rollback usando backup: \$BACKUP_DIR"
              cd "\$DIFY_DIR"
              
              if command -v docker-compose &> /dev/null; then
                COMPOSE_CMD="docker-compose"
              else
                COMPOSE_CMD="docker compose"
              fi
              
              # Garantir que o .env está no local correto
              if [ -f "\$BACKUP_DIR/.env" ]; then
                sudo cp "\$BACKUP_DIR/.env" "\$DIFY_DIR/.env"
                sudo cp "\$BACKUP_DIR/.env" "\$DIFY_DIR/docker/.env"
                sudo chown ubuntu:ubuntu "\$DIFY_DIR/.env"
                sudo chown ubuntu:ubuntu "\$DIFY_DIR/docker/.env"
              fi
              
              if [ -f "\$BACKUP_DIR/docker-compose.yaml" ]; then
                sudo cp "\$BACKUP_DIR/docker-compose.yaml" "\$DIFY_DIR/docker/docker-compose.yaml"
                sudo chown ubuntu:ubuntu "\$DIFY_DIR/docker/docker-compose.yaml"
              fi
              
              # Executar do diretório docker/ para que o .env seja encontrado automaticamente
              cd "\$DIFY_DIR/docker"
              sudo \$COMPOSE_CMD -f docker-compose.yaml down
              sudo \$COMPOSE_CMD -f docker-compose.yaml up -d
              echo "Rollback concluído"
            else
              echo "Nenhum backup encontrado para rollback"
            fi
          EOF

